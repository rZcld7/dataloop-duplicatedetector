"""
Script para diagnosticar importaciones circulares en el proyecto DataLoop
"""

import os
import sys
import ast
import re
from pathlib import Path
from typing import Dict, List, Set, Tuple
from collections import defaultdict, deque


class ImportAnalyzer:
    """Analizador de importaciones para detectar ciclos"""
    
    def __init__(self, project_root: str):
        self.project_root = Path(project_root)
        self.imports_graph = defaultdict(set)
        self.file_imports = {}
        self.python_files = []
        
    def find_python_files(self) -> List[Path]:
        """Encuentra todos los archivos Python en el proyecto"""
        python_files = []
        
        # Buscar en src/ principalmente
        src_dir = self.project_root / "src"
        if src_dir.exists():
            for file_path in src_dir.rglob("*.py"):
                if not any(part.startswith('.') for part in file_path.parts):
                    python_files.append(file_path)
        
        # Buscar en la ra√≠z tambi√©n
        for file_path in self.project_root.glob("*.py"):
            python_files.append(file_path)
            
        self.python_files = python_files
        return python_files
    
    def extract_imports(self, file_path: Path) -> Set[str]:
        """Extrae las importaciones de un archivo Python"""
        imports = set()
        
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()
            
            # Parsear el AST
            try:
                tree = ast.parse(content)
            except SyntaxError as e:
                print(f"‚ö†Ô∏è  Error de sintaxis en {file_path}: {e}")
                return imports
            
            for node in ast.walk(tree):
                if isinstance(node, ast.Import):
                    for alias in node.names:
                        imports.add(alias.name)
                        
                elif isinstance(node, ast.ImportFrom):
                    if node.module:
                        imports.add(node.module)
                        # Tambi√©n agregar importaciones espec√≠ficas para detectar ciclos m√°s granulares
                        for alias in node.names:
                            full_import = f"{node.module}.{alias.name}"
                            imports.add(full_import)
            
            return imports
            
        except Exception as e:
            print(f"‚ùå Error leyendo {file_path}: {e}")
            return imports
    
    def get_module_name(self, file_path: Path) -> str:
        """Convierte un path de archivo a nombre de m√≥dulo"""
        try:
            # Hacer el path relativo al proyecto
            rel_path = file_path.relative_to(self.project_root)
            
            # Convertir path a nombre de m√≥dulo
            parts = list(rel_path.parts)
            if parts[-1] == "__init__.py":
                parts = parts[:-1]
            else:
                parts[-1] = parts[-1].replace(".py", "")
            
            return ".".join(parts)
            
        except ValueError:
            # Si el archivo no est√° dentro del proyecto
            return str(file_path.stem)
    
    def build_import_graph(self):
        """Construye el grafo de importaciones"""
        print("üîç Analizando importaciones...")
        
        files = self.find_python_files()
        print(f"üìÅ Encontrados {len(files)} archivos Python")
        
        for file_path in files:
            module_name = self.get_module_name(file_path)
            imports = self.extract_imports(file_path)
            
            self.file_imports[module_name] = {
                'file_path': file_path,
                'imports': imports
            }
            
            # Filtrar solo importaciones internas del proyecto
            internal_imports = set()
            for imp in imports:
                # Considerar importaciones que empiecen con 'src.' o sean m√≥dulos internos
                if (imp.startswith('src.') or 
                    imp.startswith('core.') or 
                    imp.startswith('utils.') or 
                    imp.startswith('ui.') or
                    imp in [self.get_module_name(f) for f in files]):
                    internal_imports.add(imp)
            
            self.imports_graph[module_name] = internal_imports
            
        print(f"üìä Construido grafo con {len(self.imports_graph)} m√≥dulos")
    
    def find_cycles(self) -> List[List[str]]:
        """Encuentra ciclos en el grafo de importaciones usando DFS"""
        visited = set()
        rec_stack = set()
        cycles = []
        
        def dfs(node: str, path: List[str]) -> bool:
            if node in rec_stack:
                # Encontramos un ciclo
                cycle_start = path.index(node)
                cycle = path[cycle_start:] + [node]
                cycles.append(cycle)
                return True
            
            if node in visited:
                return False
            
            visited.add(node)
            rec_stack.add(node)
            path.append(node)
            
            # Visitar dependencias
            for dependency in self.imports_graph.get(node, set()):
                # Normalizar el nombre del m√≥dulo para la comparaci√≥n
                dep_normalized = self._normalize_module_name(dependency)
                if dep_normalized in self.imports_graph:
                    dfs(dep_normalized, path.copy())
            
            rec_stack.remove(node)
            path.pop()
            return False
        
        # Ejecutar DFS desde cada nodo no visitado
        for module in self.imports_graph:
            if module not in visited:
                dfs(module, [])
        
        return cycles
    
    def _normalize_module_name(self, module_name: str) -> str:
        """Normaliza nombres de m√≥dulos para comparaci√≥n"""
        # Remover partes espec√≠ficas de importaciones (ej: 'src.utils.config.Config' -> 'src.utils.config')
        parts = module_name.split('.')
        
        # Si es una importaci√≥n espec√≠fica (√∫ltima parte empieza con may√∫scula), quitar la √∫ltima parte
        if len(parts) > 1 and parts[-1][0].isupper():
            return '.'.join(parts[:-1])
        
        return module_name
    
    def find_simple_cycles(self) -> List[Tuple[str, str]]:
        """Encuentra ciclos simples (A->B->A)"""
        simple_cycles = []
        
        for module_a in self.imports_graph:
            for dep_b in self.imports_graph[module_a]:
                dep_b_norm = self._normalize_module_name(dep_b)
                if dep_b_norm in self.imports_graph:
                    for dep_c in self.imports_graph[dep_b_norm]:
                        dep_c_norm = self._normalize_module_name(dep_c)
                        if dep_c_norm == module_a:
                            simple_cycles.append((module_a, dep_b_norm))
        
        return simple_cycles
    
    def analyze_config_dependencies(self) -> Dict[str, List[str]]:
        """Analiza espec√≠ficamente las dependencias de Config"""
        config_deps = {}
        
        for module, data in self.file_imports.items():
            if 'config' in module.lower():
                imports = [imp for imp in data['imports'] if imp.startswith('src.')]
                config_deps[module] = imports
                
        return config_deps
    
    def find_who_imports_config(self) -> List[str]:
        """Encuentra qu√© m√≥dulos importan Config"""
        importers = []
        
        for module, data in self.file_imports.items():
            imports = data['imports']
            for imp in imports:
                if 'config' in imp.lower() and 'Config' in imp:
                    importers.append(module)
                    break
        
        return importers
    
    def print_detailed_analysis(self):
        """Imprime un an√°lisis detallado"""
        print("\n" + "="*80)
        print("üîç AN√ÅLISIS DETALLADO DE IMPORTACIONES")
        print("="*80)
        
        # An√°lisis general
        print(f"\nüìä ESTAD√çSTICAS GENERALES:")
        print(f"   ‚Ä¢ Archivos Python: {len(self.python_files)}")
        print(f"   ‚Ä¢ M√≥dulos con importaciones: {len(self.imports_graph)}")
        
        # An√°lisis de Config espec√≠ficamente
        print(f"\nüîß AN√ÅLISIS DE CONFIG:")
        config_deps = self.analyze_config_dependencies()
        if config_deps:
            for module, imports in config_deps.items():
                print(f"   ‚Ä¢ {module}:")
                print(f"     üìÅ Archivo: {self.file_imports[module]['file_path']}")
                if imports:
                    print(f"     üì• Importa: {', '.join(imports)}")
                else:
                    print(f"     üì• No importa m√≥dulos internos")
        
        # Qui√©n importa Config
        print(f"\nüéØ M√ìDULOS QUE IMPORTAN CONFIG:")
        config_importers = self.find_who_imports_config()
        if config_importers:
            for importer in config_importers:
                print(f"   ‚Ä¢ {importer}")
                print(f"     üìÅ {self.file_imports[importer]['file_path']}")
        else:
            print("   ‚úÖ Ning√∫n m√≥dulo importa Config directamente")
        
        # Buscar ciclos simples
        print(f"\nüîÑ CICLOS SIMPLES DETECTADOS:")
        simple_cycles = self.find_simple_cycles()
        if simple_cycles:
            for cycle in simple_cycles:
                print(f"   ‚ùå {cycle[0]} ‚Üî {cycle[1]}")
        else:
            print("   ‚úÖ No se detectaron ciclos simples")
        
        # Buscar todos los ciclos
        print(f"\nüåÄ TODOS LOS CICLOS:")
        all_cycles = self.find_cycles()
        if all_cycles:
            for i, cycle in enumerate(all_cycles, 1):
                print(f"   ‚ùå Ciclo {i}: {' ‚Üí '.join(cycle)}")
        else:
            print("   ‚úÖ No se detectaron ciclos")
        
        # Mostrar grafo de importaciones para debug
        print(f"\nüï∏Ô∏è GRAFO DE IMPORTACIONES (solo m√≥dulos internos):")
        for module, imports in self.imports_graph.items():
            if imports:
                print(f"   üì¶ {module}:")
                for imp in sorted(imports):
                    print(f"      ‚îî‚îÄ {imp}")
    
    def generate_fix_suggestions(self) -> List[str]:
        """Genera sugerencias para arreglar los ciclos"""
        suggestions = []
        
        # Sugerencias generales
        suggestions.append("üîß SUGERENCIAS PARA ARREGLAR CICLOS:")
        suggestions.append("")
        
        config_deps = self.analyze_config_dependencies()
        config_importers = self.find_who_imports_config()
        
        if config_importers:
            suggestions.append("1. üìù ELIMINAR IMPORTACIONES DE CONFIG:")
            for importer in config_importers:
                suggestions.append(f"   ‚Ä¢ En {importer}: remover 'from src.utils.config import Config'")
            suggestions.append("")
        
        if any(config_deps.values()):
            suggestions.append("2. üö´ ELIMINAR IMPORTACIONES EN CONFIG:")
            for module, imports in config_deps.items():
                if imports:
                    suggestions.append(f"   ‚Ä¢ En {module}: remover importaciones de {', '.join(imports)}")
            suggestions.append("")
        
        suggestions.append("3. üèóÔ∏è REESTRUCTURAR C√ìDIGO:")
        suggestions.append("   ‚Ä¢ Mover l√≥gica que depende de otros m√≥dulos fuera de Config")
        suggestions.append("   ‚Ä¢ Usar lazy loading para dependencias")
        suggestions.append("   ‚Ä¢ Crear funciones factory en lugar de importaciones directas")
        suggestions.append("")
        
        suggestions.append("4. üìã PATR√ìN RECOMENDADO:")
        suggestions.append("   ‚Ä¢ Config debe ser independiente (no importar nada del proyecto)")
        suggestions.append("   ‚Ä¢ Otros m√≥dulos pueden importar Config")
        suggestions.append("   ‚Ä¢ Usar m√©todos get/set para acceso din√°mico")
        
        return suggestions


def main():
    """Funci√≥n principal del diagn√≥stico"""
    print("üöÄ DIAGN√ìSTICO DE IMPORTACIONES CIRCULARES - DataLoop")
    print("="*60)
    
    # Detectar directorio del proyecto
    current_dir = Path.cwd()
    project_root = None
    
    # Buscar hacia arriba hasta encontrar src/ o .git/
    for parent in [current_dir] + list(current_dir.parents):
        if (parent / "src").exists() or (parent / ".git").exists():
            project_root = parent
            break
    
    if not project_root:
        project_root = current_dir
        print(f"‚ö†Ô∏è  No se encontr√≥ ra√≠z del proyecto, usando: {project_root}")
    else:
        print(f"üìÅ Ra√≠z del proyecto detectada: {project_root}")
    
    # Crear analizador
    analyzer = ImportAnalyzer(str(project_root))
    
    try:
        # Construir grafo de importaciones
        analyzer.build_import_graph()
        
        # Realizar an√°lisis detallado
        analyzer.print_detailed_analysis()
        
        # Generar sugerencias
        print("\n" + "="*80)
        suggestions = analyzer.generate_fix_suggestions()
        for suggestion in suggestions:
            print(suggestion)
        
        print("\n" + "="*80)
        print("‚úÖ An√°lisis completado.")
        print("üí° Tip: Copia la salida para analizar los ciclos detectados")
        
    except Exception as e:
        print(f"‚ùå Error durante el an√°lisis: {e}")
        import traceback
        traceback.print_exc()


if __name__ == "__main__":
    main()
    